/**
 * Timestamp-based Regeneration Tests
 *
 * Tests that tskill.generated.mjs files are only regenerated when
 * tskill.md is newer than the generated file (using file modification timestamps).
 */

import { describe, it, before, after, beforeEach, afterEach } from 'node:test';
import assert from 'node:assert/strict';
import path from 'node:path';
import fs from 'node:fs';
import { setTimeout as sleep } from 'node:timers/promises';

import {
    createTempDir,
    cleanupTempDir,
    SKILL_DEFINITIONS,
} from './helpers/testHelpers.mjs';

// Import the DBTableSkillsSubsystem components
const achillesLibPath = path.resolve(
    import.meta.dirname,
    '../../coral-agent/node_modules/achillesAgentLib/DBTableSkillsSubsystem'
);

describe('Timestamp-based Regeneration', () => {
    let tempDir;
    let skillsDir;
    let DBTableSkillsSubsystem;
    let serializeFunctions;

    before(async () => {
        // Setup temp directory
        const dirs = createTempDir('temp_timestamp');
        tempDir = dirs.tempDir;
        skillsDir = dirs.skillsDir;

        // Import the modules
        try {
            const subsystemModule = await import(path.join(achillesLibPath, 'DBTableSkillsSubsystem.mjs'));
            DBTableSkillsSubsystem = subsystemModule.DBTableSkillsSubsystem || subsystemModule.default;

            const generatorModule = await import(path.join(achillesLibPath, 'FunctionGenerator.mjs'));
            serializeFunctions = generatorModule.serializeFunctions;
        } catch (e) {
            console.log('Note: Could not import DBTableSkillsSubsystem directly:', e.message);
        }
    });

    after(() => {
        cleanupTempDir(tempDir);
    });

    describe('serializeFunctions', () => {
        it('should not include tskillSource in output', async () => {
            if (!serializeFunctions) {
                console.log('Skipping: serializeFunctions not available');
                return;
            }

            const mockFunctions = {
                presenters: {
                    presenter_name: 'function presenter_name(value) { return value; }',
                },
                resolvers: {},
                validators: {
                    validator_name: 'function validator_name(value) { return ""; }',
                },
                enumerators: {},
                derivators: {},
                fieldNamePresenters: {},
                global: {
                    prepareRecord: 'async function prepareRecord(record) { return record; }',
                },
            };

            const result = serializeFunctions(mockFunctions);

            // Should NOT contain tskillSource
            assert.ok(!result.includes('tskillSource'), 'Output should not contain tskillSource');

            // Should contain the comment header
            assert.ok(
                result.includes('Generated by DBTableSkillsSubsystem'),
                'Should contain generation comment'
            );

            // Should contain the functions
            assert.ok(result.includes('presenter_name'), 'Should contain presenter function');
            assert.ok(result.includes('validator_name'), 'Should contain validator function');
            assert.ok(result.includes('prepareRecord'), 'Should contain global function');
        });

        it('should ignore tskillSource parameter for backwards compatibility', async () => {
            if (!serializeFunctions) {
                console.log('Skipping: serializeFunctions not available');
                return;
            }

            const mockFunctions = {
                presenters: {},
                resolvers: {},
                validators: {},
                enumerators: {},
                derivators: {},
                fieldNamePresenters: {},
                global: {},
            };

            // Pass tskillSource as second parameter (for backwards compatibility)
            const result = serializeFunctions(mockFunctions, '# Some markdown content');

            // Should still NOT include tskillSource in output
            assert.ok(!result.includes('tskillSource'), 'Output should not contain tskillSource');
            assert.ok(!result.includes('Some markdown'), 'Output should not contain markdown content');
        });
    });

    describe('File timestamp comparison', () => {
        let testSkillDir;

        beforeEach(() => {
            testSkillDir = path.join(skillsDir, 'TestTimestampSkill');
            fs.mkdirSync(testSkillDir, { recursive: true });
        });

        afterEach(() => {
            if (fs.existsSync(testSkillDir)) {
                fs.rmSync(testSkillDir, { recursive: true, force: true });
            }
        });

        it('should detect when tskill.md is newer than generated file', async () => {
            const tskillPath = path.join(testSkillDir, 'tskill.md');
            const generatedPath = path.join(testSkillDir, 'tskill.generated.mjs');

            // Create generated file first
            fs.writeFileSync(generatedPath, '// old generated content');

            // Wait a bit to ensure different timestamps
            await sleep(100);

            // Create tskill.md after (newer)
            fs.writeFileSync(tskillPath, SKILL_DEFINITIONS.tskill);

            // Check timestamps
            const tskillStat = fs.statSync(tskillPath);
            const generatedStat = fs.statSync(generatedPath);

            assert.ok(
                tskillStat.mtimeMs > generatedStat.mtimeMs,
                'tskill.md should be newer than generated file'
            );

            const needsRegeneration = tskillStat.mtimeMs > generatedStat.mtimeMs;
            assert.ok(needsRegeneration, 'Should detect regeneration is needed');
        });

        it('should detect when generated file is newer than tskill.md', async () => {
            const tskillPath = path.join(testSkillDir, 'tskill.md');
            const generatedPath = path.join(testSkillDir, 'tskill.generated.mjs');

            // Create tskill.md first
            fs.writeFileSync(tskillPath, SKILL_DEFINITIONS.tskill);

            // Wait a bit to ensure different timestamps
            await sleep(100);

            // Create generated file after (newer)
            fs.writeFileSync(generatedPath, '// new generated content');

            // Check timestamps
            const tskillStat = fs.statSync(tskillPath);
            const generatedStat = fs.statSync(generatedPath);

            assert.ok(
                generatedStat.mtimeMs > tskillStat.mtimeMs,
                'Generated file should be newer than tskill.md'
            );

            const needsRegeneration = tskillStat.mtimeMs > generatedStat.mtimeMs;
            assert.ok(!needsRegeneration, 'Should detect regeneration is NOT needed');
        });

        it('should handle touch to force regeneration', async () => {
            const tskillPath = path.join(testSkillDir, 'tskill.md');
            const generatedPath = path.join(testSkillDir, 'tskill.generated.mjs');

            // Create both files with generated being newer
            fs.writeFileSync(tskillPath, SKILL_DEFINITIONS.tskill);
            await sleep(100);
            fs.writeFileSync(generatedPath, '// generated content');

            // Verify generated is newer
            let tskillStat = fs.statSync(tskillPath);
            let generatedStat = fs.statSync(generatedPath);
            assert.ok(generatedStat.mtimeMs > tskillStat.mtimeMs, 'Generated should be newer initially');

            // Touch tskill.md to force regeneration
            await sleep(100);
            const now = new Date();
            fs.utimesSync(tskillPath, now, now);

            // Verify tskill.md is now newer
            tskillStat = fs.statSync(tskillPath);
            generatedStat = fs.statSync(generatedPath);

            assert.ok(
                tskillStat.mtimeMs > generatedStat.mtimeMs,
                'After touch, tskill.md should be newer'
            );
        });

        it('should handle missing generated file', async () => {
            const tskillPath = path.join(testSkillDir, 'tskill.md');
            const generatedPath = path.join(testSkillDir, 'tskill.generated.mjs');

            // Only create tskill.md
            fs.writeFileSync(tskillPath, SKILL_DEFINITIONS.tskill);

            // Generated file doesn't exist
            const generatedExists = fs.existsSync(generatedPath);
            assert.ok(!generatedExists, 'Generated file should not exist');

            // In this case, regeneration is needed (new generation)
            // The subsystem handles this by falling through to fresh generation
        });
    });

    describe('Generated file format', () => {
        let testSkillDir;

        beforeEach(() => {
            testSkillDir = path.join(skillsDir, 'TestFormatSkill');
            fs.mkdirSync(testSkillDir, { recursive: true });
        });

        afterEach(() => {
            if (fs.existsSync(testSkillDir)) {
                fs.rmSync(testSkillDir, { recursive: true, force: true });
            }
        });

        it('should not require tskillSource export in generated file', async () => {
            const generatedPath = path.join(testSkillDir, 'tskill.generated.mjs');

            // Write a minimal generated file without tskillSource
            const minimalGenerated = `// Generated by DBTableSkillsSubsystem - regenerate with /generate command or touch tskill.md

export function validator_name(value) {
    if (!value) return JSON.stringify({ field: 'name', error: 'Required', value });
    return '';
}

export const functions = {
    presenters: {},
    resolvers: {},
    validators: { validator_name },
    enumerators: {},
    derivators: {},
    fieldNamePresenters: {},
    global: {},
};
`;

            fs.writeFileSync(generatedPath, minimalGenerated);

            // Should be valid syntax
            let syntaxError = null;
            try {
                await import(generatedPath + '?t=' + Date.now());
            } catch (e) {
                syntaxError = e;
            }

            assert.ok(!syntaxError, 'Generated file should have valid syntax');
        });

        it('should export functions object', async () => {
            const generatedPath = path.join(testSkillDir, 'tskill.generated.mjs');

            const validGenerated = `// Generated by DBTableSkillsSubsystem

export function validator_test(value) {
    return '';
}

export const functions = {
    presenters: {},
    resolvers: {},
    validators: { validator_test },
    enumerators: {},
    derivators: {},
    fieldNamePresenters: {},
    global: {},
};
`;

            fs.writeFileSync(generatedPath, validGenerated);

            const imported = await import(generatedPath + '?t=' + Date.now());

            assert.ok(imported.functions, 'Should export functions object');
            assert.ok(imported.functions.validators, 'Should have validators category');
            assert.ok(imported.functions.validators.validator_test, 'Should have validator function');
        });
    });
});
